var res1 ='number' + 3 + 3;
console.log(res1);
// произошла конкатенация, потому что при арифметической операции сложения (+) была добавлена строка 'number'. Результат number33
var res2 = null + 3;
console.log(res2);
// null преобразуется в 0. Результат 0 + 3 = 3
var res3 = 5 && "qwerty";
console.log(res3);
/** В данном случае - это операция с булевым оператором AND &&. Левый операнд 5 = true, так как любое число > 0 = true. Правый операнд "qwerty" = true. Поэтому цикл проходит до конца. И возвращается последнее значение, то есть это строка "qwerty".
 */ 
var res4 = +'40' + +'2' + "hillel";
console.log(res4);
/** Унарный плюс конвертирует '40' в число 40, а '2' в 2. Сумма 40+2=42. "hillel" - это строка. Поэтому при сложении со строкой происходит конкатенация. Результат 42hillel
 */
var res5 = '10' - 5 === 6;
console.log(res5);
/** Строгое равно проверяет на равенство две величины, при этом тип каждой из величин перед сравнением не изменяется (не приводится). '10'- это строка, которая не преобразуется в число, а 6 - это number. Поэтому возвращается результат false.
 */ 
var res6 = true + false;
console.log(res6);
// true было приведено к 1, а false к 0. Результат 1 + 0 = 1
var res7 = '4px' - 3;
console.log(res7);
// '4px' - это строка. В случае вычитания из строки какого-то числа, получаем NaN - not a number.
var res8 = '4' - 3;
console.log(res8);
// строка '4' была приведена к числу 4. Результат 4 - 3 = 1
var res9 = '6' + 3 ** 0;
console.log(res9);
// '6' приводится к 6. Любое число в 0 степени = 1. То есть 3**0 = 1. А затем происходит конкатенация 6 и 1. Результа слияния 61.
var res10 = 12 / '6';
console.log(res10);
// строка '6' была приведена к числу 6. Результат 12 / 6 = 2
var res11 = '10' + (5 === 6);
console.log(res11);
/** 5 не равно 6, поэтому (5===6) вызывает false. Строка '10' преобразуется в 10. А потом происходит конкатенация 10 и false. Результат 10false
*/
var res12 = null == '';
console.log(res12);
/** если сравнивать null с другими ложными значениями при помощи оператора нестрогого сравнения ==, то он не равен ничему кроме самого себя или undefined. Поэтому результат False.
 */
var res13 = 3 ** (9 / 3);
console.log(res13);
/** сначала выполняем деление в скобках 9/3 = 3. Таким образом получаем степень, в которую будем возводить число 3. Возводим число 3 в полученную степень 3, т.е. 3*3*3 = 27. Результат 27
 */
var res14 = !!'false' == !!'true';
console.log(res14);
/** Не пустая строка с одним оператором ! возвращает false, а с двумя !! обратно вернет true. То есть у нас непустая строка 'false' вернет true. И непустая строка 'true' вернет true. Таким образом получаем сравнение true == true. Значит результат выведения true
 */
var res15 = 0 || '0' && 1;
console.log(res15);
/** Оператор AND && имеет бОльшую приоритетность, чем OR ||. Поэтому сначала смотрим '0' && 1. В данном случае оба операнда имеют истинное значение. Поэтому цикл проходит до конца. И как результат берется последнее истинное значение 1. А теперь рассматриваем операцию OR ||. И получается рассматриваем 0 || 1. В случае с оператором OR для возвращения true необходим хотя бы один операнд true. И берется истинное значение для выведения (в данном случае правый операнд 1). Результат 1.
 */
var res17 = false && true || true;
console.log(res17);
/** Сначала смотрим операцию AND &&, то есть false && true. В данном случае операция не проходит до конца, потому что false = false. Теперь рассматриваем операцию OR ||. И получается рассматриваем false || true. В случае с опертором OR для возвращения true необходим хотя бы один операнд true. Таким образом, у нас возвращается true.
*/
var res18 = false && (false || true);
console.log(res18);
/** У нас получается два операнда для операции AND &&. Первый false, а второй - результат от (false || true), которой сработает как true. Получем false && true. Если в операции AND операнд равен false, то дальше цикл не идет. Результат - false
 */
var res19 = (+null == false) < 1 ** 5;
console.log(res19);
/** Сначала рассматриваем нестрогое сравнение слева (+null == false). +null приводит к 0, что сработает как false. То есть получаем (false == false). Таким образом сравнение истинное и приводит к true. А true = 1. Теперь справа рассматриваем возведение в степень 1 ** 5 = 1. Таким образом получаем, что 1 < 1. Что выводит false.
 */